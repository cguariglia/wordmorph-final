\documentclass[a4paper, 11pt]{article}
\usepackage[T1]{fontenc}
\usepackage[portuguese]{babel}
\usepackage[utf8]{inputenc}
\usepackage[margin=2cm,includefoot,includehead,footskip=30pt]{geometry}

\usepackage{graphicx}
\graphicspath{ {imagens/} }
\usepackage{bold-extra}
\usepackage{epstopdf}
\usepackage{float}
\usepackage{scalerel}
\usepackage{enumerate}
\usepackage{indentfirst}
\usepackage{cleveref}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{color}
\usepackage{imakeidx}
\usepackage{enumitem}
\newcommand\showdiv[1]{\overline{\smash{\hstretch{.5}{)}\mkern-3.2mu\hstretch{.5}{)}}#1}}
\newcommand\ph[1]{\textcolor{white}{#1}}


\lstset{frame=tb,
  language=Matlab,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
  extendedchars=true,
  literate=	{á}{{\'a}}1	{ã}{{\~a}}1	{â}{\^{a}}1	{é}{\'{e}}1	{ç}{\c{c}}1
  			{ã}{\~{a}}1	{à}{\`{a}}1 {ê}{\^{e}}1 {í}{\'{i}}1	{ó}{\'{o}}1
  			{õ}{\~{o}}1 {ô}{\^{o}}1	{ú}{\'{u}}1 {Ç}{\c{C}}1,
}

\addto\captionsportuguese{
  \renewcommand{\contentsname}%
    {Índice}%
}

% ----- Cabeçalho e rodapé -----
\usepackage{fancyhdr}
\fancyhf{}

\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}

\rhead{Wordmorph}
\lhead{Algoritmos e Estruturas de Dados}
\rfoot{Página \thepage}
\lfoot{\small Engenharia Electrotécnica e de Computadores - IST}


\usepackage{pdfpages}

\begin{document}

\includepdf[pages={1}]{capa/capa.pdf}

\pagestyle{fancy}
\tableofcontents
\newpage

\section{Descrição do problema}
    \par O problema enunciado consiste na procura de caminhos entre palavras. Estes caminhos são, na verdade, uma sequência de palavras de tamanho igual no qual cada palavra se obtêm mudando uma ou mais letras da palavra anterior, até chegar à palavra desejada. Para além disso, todas as palavras pertencentes ao caminho têm obrigatoriamente de pertencer a um dicionário. Dicionário é definido neste caso como uma lista de palavras, que não têm obrigatoriamente de ser todas do mesmo tamanho.
    \par Como é possível a existência de vários caminhos, distingue-se cada passo do caminho pelo número de caracteres que são mudados. No fim, os custos dos caminhos somam-se para chegar ao custo final. Por exemplo, um passo no qual se mude um caracter têm o custo de $1^1$, um passo em que se mudam dois caracteres têm um custo de $2^2$, e assim sucessivamente.
    \par O objectivo final deste projecto é, dado duas palavras e o número máximo de trocas que se podem efectuar em cada passo, retornar o caminho de menor custo entre essas duas palavras.
    
\section{Abordagem do problema}
    \par Para resolver o problema, decidiu-se dividi-lo nas seguintes partes: guardar as palavras do dicionário e procurar o caminho propriamente dito. Também chegou-se à conclusão de que seria necessário guardar as palavras do dicionário num local que fosse facilmente acessível, e que não é necessário criar os grafos de todos os tamanhos de palavras que se encontram no dicionário, só dos que são pedidos.
\subsection{Procura do caminho de menor custo}
    \par A escolha óbvia para resolver este problema foi recorrer ao algorítmo de Dijkstra, que procura o caminho mais curto entre dois vértices de um dado grafo desde que nenhuma das arestas do mesmo tenha peso negativo, o que é o caso deste problema. Para podermos utilizar então o algorítmo, foi necessária a criação de um grafo representado por listas de adjacências (o algorítmo não é igual para matrizes de adjacência).
    \par Note-se também que cada conjunto de palavras de um dado tamanho vai requerer o seu próprio grafo.
    
\section{Implementação do programa}
    \par Dividiu-se então o programa em três partes distintas: uma parte referente às estruturas de dados, uma parte que se relaciona diretamente com o problema a resolver, e por fim todas as restantes operações que não pertencem a nenhum dos anteriores grupos. No código, estas partes equivalem aos ficheiros datastructs.c, words.c e utils.c respectivamente.
    \par Para evitar alocações de memória desnecessárias, percorrem-se todas as linhas do ficheiro de dicionário duas vezes. Uma para contar o número de palavras que existem de cada tamanho de palavra, outra para copiar as palavras do ficheiro para a matriz que representa o dicionário, cujo tamanho é alocado baseando-se no número obtido anteriormente. Assumiu-se que nunca existiriam palavras de mais de cem letras.
    \par Como mencionado na secção anterior, rapidamente chegou-se à conclusão de que é desnecessário criar grafos que não vão ser utilizados. Por isso, também percorre-se uma vez pelo ficheiro de problemas sem os começar a resolver, para saber que tamanhos de palavras existem no ficheiro, e qual número máximo de caracteres que mudam entre duas palavras do caminho.
    
\subsection{Descrição das estruturas de dados}
    \par Como referido acima, foi claro que seria necessária a criação de uma lista de adjacências, então foi implementada uma lista genérica. Esta é definida usando void * (definido em datastructs.h, e a partir daqui referido como Item), para os quais se pode passar qualquer ponteiro, assegurando a generalidade da implementação.
    \par As listas definidas foram então utilizadas na definição do grafo pois este é implementado usando uma lista de adjacências. Os grafos foram definidos de forma genérica, com um reparo - a implementação dos dados usados na lista estão visíveis ao cliente. Todos os novos elementos desta lista são inseridos na primeira posição (head).
    \par Como terá de existir um grafo para cada tamanho de palavras, decidiu-se usar um vetor para guardá-los no qual o índice corresponde ao tamanho das palavras representadas no grafo (i.e. all{\_}arrays[3] contêm o grafo das palavras de tamanho 3).
    \par Por fim, a descrição do algorítmo de Dijkstra requer um acervo, também este definida de forma genérica no código. Neste caso, o acervo foi implementado usando uma fila prioritária, que por sua vez foi implementada usando um vector. Este vector tem um tamanho fixo, definido na sua incialização, mas usou-se outra vaŕiavel (q$\rightarrow$first) para que exista um "vector virtual"  dentro do vector maior. Outra das variáveis que foi útil foi um vector indexado por vértices que diz onde o vértice está na heap (q$\rightarrow$vert{\_}pos), que evita que se tenha de fazer procura linear cada vez que se quer encontrar um vértice na heap.
    
\subsection{Descrição dos algoritmos}
    \par Claramente, o algorítmo crucial ao programa foi o algoritmo de Dijkstra, usando a variação que encontra o caminho mais curto entre dois vértices e não a que encontra o caminho mais curto entre um vértice e todos os outros vértices do grafo, ou seja, parando quando o elemento que sai da heap é o vértice a que se quer chegar.

\section{Complexidade do programa}
    \par Examinando o programa, chega-se à conclusão de que existem duas grandes partes no problema. Em ambos os casos, $n$ representa o número total de palavras com o mesmo tamanho.
    \begin{description}[align=left]
        \item[Criação de grafo] Para inserir todas as palavras no grafo, é necessário comparar todas as palavras duas a duas. No código, como para cada palavra do dicionário só é necessário comparar as palavras anteriores a esta, o que acontece é $1 + 2 + 3 + ... + n = \frac{n^2}{2} + \frac{n}{2}$, que é majorado por $n^2$ concluindo-se então que a complexidade será $O(n^2)$.
        Em termos de memória, 
        \item[Algorítmo de Dijkstra] O algorítmo de Dijkstra, usando uma heap, corre em $O(|e| + |n|log(|n|))$, em que $e$ é o número de ligações entre palavras e assumindo que a procura de elementos dentro da heap é $O(1)$.
    \end{description}

\section{Análise do programa}

\section{Exemplo}
    \par Considerando como exemplo um ficheiro de problemas com:
        \begin{center}
        \texttt{massa pasta 3 \\
        pasta pasta 1 \\
        pasta parte 2 \\
        }
        \end{center}
        
    \par E considerando que um dicionário um ficheiro com palavras não acentuadas, sem hífen, separadas por espaços ou \textit{newlines} e que inclui todas as palavras que se encontram no ficheiro de problemas, como por exemplo: 
        \begin{center}
        \texttt{juiz largo \\
        massa parte \\
        pasta rei \\
        ...}
        \end{center}
        
    \par Então, os passos que se efectuam para resolver o ficheiro de problemas enunciado são:
    
    \begin{enumerate}[align=left]
        \item Lê-se o ficheiro de problemas de forma a identificar o número máximo de mutações entre palavras de um determinado tamanho, ignorando casos triviais como duas palavras iguais ou duas palavras que apenas diferem em uma letra.
        \item Guarda-se as palavras com tamanhos relevantes à resolução numa matriz.
    \end{enumerate}

\section{Bibliografia}


\end{document}
